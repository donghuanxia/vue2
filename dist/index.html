 <!DOCTYPE html>
 <html lang="en">
 <head>
     <meta charset="UTF-8">
     <meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Document</title>
 </head>
 <body>
     <div id="app">{{message}}</div>
     <script src="./vue.js"></script>
     <script>
         //vue默认支持响应式数据变化（双向绑定）
         //1、双向绑定页面得需要能修改（表单，radio,checkbox,input ,textarea）数据变化可以影响视图显示
         //2、响应式数据变化，能监控到数据变化，并且更新视图（单向的）
         //vue 模式并不是mvvm,vue默认只是做视图的，渐进式 + 组件化 + vue-router + vuex + vue-cli
         //数据变化是如何变化的，Object.defineProperty,将对象中原有的属性更改成带有get和set的一个属性，这样当修改的时候，会触发 set ->更新视图

         let vm = new Vue({
             el:'#app',
            //  data:{//可以是对象也可以是函数
            //      message:'hello world'
            //  }
            //数组修改索引不会导致视图更新，修改length也不会更新
            //vue3中为了兼容proxy 内部对数组用的就是defineProperty
            //正常用户修改数组，无非采用的数组变异方法，push pop splice shift unshift reverse sort
            data(){
                console.log('----',this)
                return{
                    message:'hello world',
                    a:{
                        b:1
                    },
                    arr:[1,2,3,4],
                    arr1:[{name:'ddd'}]
                }
                
            },
            template:'<div id= "app" ></div>'
         })
         //vm.arr1[0].name = 'hcc'//走对象的逻辑
         //vm.arr1[1] = 100//不会更新，不能通过索引和更改数组的长度更新视图，那七个方法可以
         //vm.arr = {a:100}
         //vm.arr.a = 200
         //vm.arr.b = 2//vue2无法劫持到不存在的属性，新增不存在的书香不会更新视图
         vm.arr1.push({a:999})
         vm.arr1.a = 200
     </script>
 </body>
 </html>